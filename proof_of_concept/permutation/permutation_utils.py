import networkx as nx
import numpy as np
from typing import Set, List, Tuple, Dict, Iterable, Callable
import random
from collections import deque
import matplotlib.pyplot as plt
import scienceplots
import matplotlib.patches as mpatches
import sys
import os

# Add parent directory to path for imports
sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))
from hamiltonian_utils import PauliString, Hamiltonian

plt.style.use(["science", "no-latex"])


def _cycles_to_map(cycles: Iterable[Iterable[int]], n_qubits: int) -> Tuple[int, ...]:
    """Converts a list of disjoint cycles into a full permutation map (tuple)."""
    perm_map = list(range(n_qubits))
    for cycle in cycles:
        if not cycle:
            continue
        cycle_list = list(cycle)
        for i in range(len(cycle_list)):
            current_qubit = cycle_list[i]
            next_qubit = cycle_list[(i + 1) % len(cycle_list)]
            perm_map[current_qubit] = next_qubit
    return tuple(perm_map)


def _compose_maps(map1: Tuple[int, ...], map2: Tuple[int, ...]) -> Tuple[int, ...]:
    """Composes two permutation maps: map1(map2(i))."""
    return tuple(map1[map2[i]] for i in range(len(map1)))


def _get_permutation_group(
    generator_cycles: Iterable[Iterable[int]], n_qubits: int
) -> Set[Tuple[int, ...]]:
    """Generates the full permutation group from a set of generator cycles."""
    identity_map = tuple(range(n_qubits))
    generator_maps = [_cycles_to_map([cycle], n_qubits) for cycle in generator_cycles]
    group_elements: Set[Tuple[int, ...]] = {identity_map}
    frontier: deque[Tuple[int, ...]] = deque([identity_map])
    while frontier:
        current_map = frontier.popleft()
        for gen_map in generator_maps:
            new_map = _compose_maps(current_map, gen_map)
            if new_map not in group_elements:
                group_elements.add(new_map)
                frontier.append(new_map)
    return group_elements


def _apply_permutation_int(
    pauli_list_int: List[int], perm_map: Tuple[int, ...]
) -> Tuple[int, ...]:
    """
    Applies the permutation action to an integer-represented Pauli string.
    The operator at old position 'i' moves to new position 'j = perm_map[i]'.
    """
    n = len(pauli_list_int)
    # 0 represents the Identity operator
    new_pauli = [0] * n
    for i in range(n):
        j = perm_map[i]  # j = sigma(i)
        new_pauli[j] = pauli_list_int[i]
    return tuple(new_pauli)


def generate_symmetric_hamiltonian_int(
    n_qubits: int,
    symmetry_generators: Iterable[Iterable[int]],
    n_seed_terms: int,
    locality: int,
    coeff_distribution: Callable[[], float] = lambda: np.random.normal(0, 1),
) -> Hamiltonian:
    """
    Generates a k-local Hamiltonian on n_qubits that is symmetric
    under the permutation group generated by `symmetry_generators`.

    Args:
        n_qubits (int): Number of qubits (n).
        symmetry_generators (Iterable[Iterable[int]]):
            An iterable of generator cycles, eg., [[0, 1], [2, 3]].
        n_seed_terms (int): The number of "seed" terms to generate orbits from.
        locality (int): The locality (k) of the seed terms.
        coeff_distribution (Callable): Function to sample coefficients.

    Returns:
        Hamiltonian: The symmetric Hamiltonian object.
    """

    if locality > n_qubits or locality < 1:
        raise ValueError("Locality k must be 1 <= k <= n_qubits")

    group_permutations = _get_permutation_group(symmetry_generators, n_qubits)

    hamiltonian = Hamiltonian()
    num_orbits_generated = 0

    pauli_choices = [1, 2, 3]  # X, Y, Z

    while num_orbits_generated < n_seed_terms:
        p_list = [0] * n_qubits  # Start with identity
        indices = np.random.choice(n_qubits, locality, replace=False)
        for i in indices:
            p_list[i] = np.random.choice(pauli_choices)

        p_string = PauliString.from_list(p_list)

        if p_string in hamiltonian:
            continue

        # Generate non-zero coefficient
        coeff = 0.0
        while abs(coeff) < 1e-14:
            coeff = coeff_distribution()

        # Generate orbit under the symmetry group
        orbit = set()
        for perm_map in group_permutations:
            permuted_pauli = p_string.apply_permutation(perm_map)
            orbit.add(permuted_pauli)

        # Add all terms in the orbit with the same coefficient
        for p_in_orbit in orbit:
            if p_in_orbit not in hamiltonian:
                hamiltonian.add_term(p_in_orbit, coeff)

        num_orbits_generated += 1

    return hamiltonian


def _map_to_cycles(perm_map: Dict[int, int], n: int) -> List[List[int]]:
    """Converts a permutation map to a list of disjoint cycles."""
    cycles = []
    visited = [False] * n

    for i in range(n):
        if visited[i]:
            continue

        cycle = []
        current = i
        while not visited[current]:
            visited[current] = True
            cycle.append(current)
            current = perm_map[current]
            if current == i:
                break

        if len(cycle) > 1:
            cycles.append(cycle)

    return cycles


def check_permutation_symmetry(
    hamiltonian: Hamiltonian,
    symmetry_generators: Iterable[Iterable[Iterable[int]]],
    n_qubits: int,
    rtol: float = 1e-9,
    atol: float = 1e-12,
) -> bool:
    """
    Checks if a Hamiltonian has the specified permutation symmetries.

    Args:
        hamiltonian: The Hamiltonian object.
        symmetry_generators: An iterable of group elements, where each
                             element is a list of disjoint cycles.
                             eg., [ [[0, 1]], [[0, 9], [7, 8]] ]
        n_qubits: The total number of qubits.
        rtol: Relative tolerance for floating-point coefficient comparison.
        atol: Absolute tolerance for floating-point coefficient comparison.

    Returns:
        True if the Hamiltonian is symmetric under all generators, False otherwise.
    """

    try:
        generator_maps = [
            _cycles_to_map(gen, n_qubits) for gen in symmetry_generators
        ]
    except (IndexError, TypeError):
        print("Error: A symmetry cycle is invalid or out of bounds.")
        return False

    for gen_map in generator_maps:
        for pauli_string, coeff in hamiltonian:
            permuted_string = pauli_string.apply_permutation(gen_map)

            if permuted_string not in hamiltonian:
                print(f"Symmetry violation: Term {pauli_string} permutes to")
                print(f"{permuted_string}, which is not in the Hamiltonian.")
                print(f"Permutation map was: {gen_map}")
                return False

            permuted_coeff = hamiltonian[permuted_string]
            if not np.isclose(coeff, permuted_coeff, rtol=rtol, atol=atol):
                print(f"Symmetry violation: Term {pauli_string} (coeff {coeff})")
                print(f"permutes to {permuted_string} (coeff {permuted_coeff}).")
                print(f"Permutation map was: {gen_map}")
                return False

    return True


def _hamiltonian_to_string_int(hamiltonian: Hamiltonian) -> str:
    """Converts a Hamiltonian to a human-readable string."""
    return str(hamiltonian)


def hamiltonian_to_graph(hamiltonian: Hamiltonian) -> nx.Graph:
    """
    Converts a Hamiltonian into a graph with colored vertices and colored edges.

    Args:
        hamiltonian (Hamiltonian): The Hamiltonian to convert.

    Returns:
        nx.Graph: The graph representation of the Hamiltonian.
    """
    G = nx.Graph()
    if len(hamiltonian) == 0:
        return G

    pauli_int_to_str = {1: "X", 2: "Y", 3: "Z"}
    n_qubits = hamiltonian.n_qubits
    assert n_qubits is not None

    # V_Q = {q_1, ..., q_n}
    qubit_nodes = [f"q{i}" for i in range(n_qubits)]
    G.add_nodes_from(qubit_nodes, bipartite=0)

    for node_name in qubit_nodes:
        G.nodes[node_name]["color"] = "qubit"

    # V_T = {t_1, ..., t_m}
    for term_index, (pauli_string, coeff) in enumerate(hamiltonian):
        term_node_name = f"t{term_index}"
        G.add_node(term_node_name, bipartite=1)

        G.nodes[term_node_name]["color"] = ("term", coeff)

        for qubit_index in range(n_qubits):
            pauli_op = pauli_string[qubit_index]

            if pauli_op != 0:
                qubit_node_name = f"q{qubit_index}"
                edge_color = pauli_int_to_str[pauli_op]
                G.add_edge(qubit_node_name, term_node_name, color=edge_color)
    
    return G


def random_symmetry_generators(
    n_qubits: int, n_generators: int, max_cycle_length: int = 3
) -> List[List[int]]:
    """
    Generates random symmetry generators as disjoint cycles.

    Args:
        n_qubits (int): Number of qubits.
        n_generators (int): Number of generators to create.
        max_cycle_length (int): Maximum length of each cycle.

    Returns:
        List[List[int]]: List of generator cycles.
    """
    qubits = list(range(n_qubits))
    random.shuffle(qubits)
    generators = []
    used_qubits = set()

    for _ in range(n_generators):
        cycle_length = random.randint(2, max_cycle_length)
        cycle = []
        for q in qubits:
            if q not in used_qubits and len(cycle) < cycle_length:
                cycle.append(q)
                used_qubits.add(q)
        if len(cycle) >= 2:
            generators.append(cycle)

    return generators


def visualise_hamiltonian_graph(hamiltonian: Hamiltonian) -> None:
    """
    Visualises the Hamiltonian as a coloured bipartite graph.

    Args:
        hamiltonian (Hamiltonian): The Hamiltonian to visualise.
    """
    G = hamiltonian_to_graph(hamiltonian)

    plt.figure(figsize=(12, 8))
    ax = plt.gca()

    # Separate node sets
    qubit_nodes = {n for n, d in G.nodes(data=True) if d["bipartite"] == 0}
    term_nodes = set(G.nodes()) - qubit_nodes
    pos = nx.bipartite_layout(G, qubit_nodes, align="vertical")
    term_coeffs = [G.nodes[n].get("color", (None, 0))[1] for n in term_nodes]

    # Draw qubit nodes
    nx.draw_networkx_nodes(
        G, pos, nodelist=qubit_nodes, node_color="lightblue", node_size=500, ax=ax
    )

    # Draw term nodes
    nodes = nx.draw_networkx_nodes(
        G,
        pos,
        nodelist=term_nodes,
        node_color=term_coeffs,
        node_size=500,
        cmap='coolwarm',
        ax=ax,
    )

    # Draw colourbar for term coefficients
    plt.colorbar(nodes, ax=ax, label="Coefficient Value", shrink=0.8)

    # Get edge colours
    edge_visual_map = {"X": "red", "Y": "green", "Z": "blue"}
    edge_colors = []
    for u, v in G.edges():
        try:
            color_key = G.edges[u, v]["color"]
            edge_colors.append(edge_visual_map[color_key])
        except KeyError:
            edge_colors.append("gray")

    nx.draw_networkx_edges(G, pos, ax=ax, edge_color=edge_colors, alpha=0.7, width=1.5)

    nx.draw_networkx_labels(G, pos, ax=ax, font_size=10)

    # Add bipartite labels
    ax.text(
        0.0,
        -0.02,
        "Qubits ($V_Q$)",
        transform=ax.transAxes,
        ha="left",
        va="top",
        fontsize=12,
    )
    ax.text(
        1.0,
        -0.02,
        "Terms ($V_T$)",
        transform=ax.transAxes,
        ha="right",
        va="top",
        fontsize=12,
    )

    ax.set_xticks([])
    ax.set_yticks([])

    # Add legend for edge colours
    edge_legend_elements = [
        mpatches.Patch(color="red"),
        mpatches.Patch(color="green"),
        mpatches.Patch(color="blue"),
    ]

    ax.legend(
        handles=edge_legend_elements,
        labels=["X operator", "Y operator", "Z operator"],
        loc="upper right",
        title="Edge Type",
        bbox_to_anchor=(1.13, 0.075),
    )

    plt.title("Coloured Bipartite Graph of Hamiltonian")
    plt.tight_layout(pad=1.5)
    plt.show()

def are_generators_equivalent(
    gen1: Iterable[Iterable[int]], 
    gen2: Iterable[Iterable[int]], 
    n_qubits: int
) -> bool:
    """
    Checks if two generators in cycle format represent the same permutation.
    """
    map1 = _cycles_to_map(gen1, n_qubits)
    map2 = _cycles_to_map(gen2, n_qubits)
    
    return map1 == map2


if __name__ == "__main__":
    symmetry_generators = [[0, 1], [2, 4, 5]]

    # Hamiltonian is -1 IXY + 1 YZZ - 2 YXI + 2 ZIZ - 3 XXI + 3 YZI on 3 qubits
    hamiltonian = Hamiltonian.from_dict({
        (0, 1, 2): -1.0,
        (0, 2, 2): 1.0,
        (2, 1, 3): -2.0,
        (3, 0, 3): 2.0,
        (1, 1, 0): -3.0,
        (3, 2, 0): 3.0,
    })

    print(f"Generated Hamiltonian: {hamiltonian}")

    visualise_hamiltonian_graph(hamiltonian)
